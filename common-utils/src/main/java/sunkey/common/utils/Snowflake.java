package sunkey.common.utils;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ThreadLocalRandom;

/**
 * Created by Sunkey(SunZhiWei) on 2017/6/6.
 */
@Slf4j
public final class Snowflake {

    public interface Defaults {
        @Deprecated
        long epoch = 1288834974657L;
        long workerIdBits = 10L;
        long sequenceBits = 12L;
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private long epoch = Defaults.epoch;
        private long workerIdBits = Defaults.workerIdBits;
        private long sequenceBits = Defaults.sequenceBits;
        private long workerId = 0L;

        public Builder epoch(long epoch) {
            this.epoch = epoch;
            return this;
        }

        public Builder epochYear(String year) {
            return epoch(Dates.parseAsMillis(year, "yyyy"));
        }

        public Builder workerIdBits(long workerIdBits) {
            this.workerIdBits = workerIdBits;
            return this;
        }

        public Builder sequenceBits(long sequenceBits) {
            this.sequenceBits = sequenceBits;
            return this;
        }

        public Builder workerId(long workerId) {
            this.workerId = workerId;
            return this;
        }

        public Snowflake build() {
            if (workerId == 0L) {
                workerId = defaultWorkerId();
            }
            return new Snowflake(epoch, workerIdBits, sequenceBits, workerId);
        }

    }

    private static final Snowflake INSTANCE = newBuilder().build();

    // default construct(workerId generated by MAC Address)
    public static Snowflake getDefault() {
        return INSTANCE;
    }

    // construct by self
    // workerId & 1024(取后10bit)
    public static Snowflake forWorkerId(long workerId) {
        return newBuilder().workerId(workerId).build();
    }

    private final long epoch;
    private final long workerIdBits;
    private final long maxWorkerId;
    private final long sequenceBits;
    private final long workerIdShift;
    private final long timestampLeftShift;
    private final long sequenceMask;

    private final long workerId;
    private volatile long sequence = 0L;
    private volatile long lastTimestamp = -1L;

    private Snowflake(long epoch,
                      long workerIdBits,
                      long sequenceBits,
                      long workerId) {
        this.epoch = epoch;
        this.workerIdBits = workerIdBits;
        this.maxWorkerId = -1L ^ (-1L << workerIdBits);
        this.sequenceBits = sequenceBits;
        this.workerIdShift = sequenceBits;
        this.timestampLeftShift = sequenceBits + workerIdBits;
        this.sequenceMask = -1L ^ (-1L << sequenceBits);
        this.workerId = workerId;
        check();
        log();
    }

    private void check() {
        if (workerId > maxWorkerId || workerId < 0) {
            throw new IllegalArgumentException(
                    String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));
        }
    }

    private void log() {
        String format = String.format("[timestamp(%s)][workerId(%s)][sequence(%s)]",
                (64 - workerIdBits - sequenceBits), workerIdBits, sequenceBits);
        log.info("ID Generate Strategy [Snowflake] Loaded : \nFormat : {}\nWorkerId : {}\nTwepoch : {}",
                format, workerId, epoch);
    }

    public synchronized long nextId() {
        long timestamp = timeGen();
        if (timestamp < lastTimestamp) {
            throw new RuntimeException(
                    String.format("Clock moved backwards.  Refusing to generate id for %d milliseconds",
                            lastTimestamp - timestamp));
        }
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 10) & sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        lastTimestamp = timestamp;
        return ((timestamp - epoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;
    }

    protected long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp <= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    protected long timeGen() {
        return System.currentTimeMillis();
    }

    // STATIC UTILS FOR SNOWFLAKE
    private static long defaultWorkerId() {
        NetworkUtils.MacAddress ma = null;
        try {
            ma = NetworkUtils.getPreferredMacAddress();
        } catch (Throwable ex) {
            // ignore
        }
        if (ma != null) {
            int p1 = byteUp(ma.getData()[ma.getData().length - 2]);
            int p2 = byteUp(ma.getData()[ma.getData().length - 1]);
            int p3 = p1 << 8;
            int cd = p3 | p2;
            return 1023 & cd;
        } else {
            int ra = ThreadLocalRandom.current().nextInt(1024);
            log.error("Get MacAddress failed! use random(1024):{}", ra);
            return ra;
        }
    }

    private static int byteUp(byte b) {
        if (b < 0) return 256 + b;
        return b;
    }

}
